package day_01

import (
	"errors"
)

/*
	排序: 将 N 个数字组成的无序序列按升序排列
		1. 选择排序
			将 0 ~ N-1 上的元素逐个看一遍, 记录最小值索引, 将最小元素索引 i 与当前序列 0 交换, 此时 0 位置有序, 1 ~ N-1 无序
			将 1 ~ N-1 上的元素逐个看一遍, 记录最小值索引, 将最小元素索引 i 与当前序列 1 交换, 此时 0 ~ 1 有序, 2 ~ N-1 无序
			...
			将 N-2 ~ N-1 上的元素逐个看一遍, 记录最小值索引, 将最小元素索引 i 与当前序列 N-2 交换, 此时 0 ~ N-2 有序, 只剩 N-1
			逐个处理, 直至 0 ~ N-1 有序, 程序完成. 时间复杂度 O(N^2)

		2. 冒泡排序
			将 0 ~ N-1 上的每两个相邻的元素比较, 若第一个元素比第二个元素大, 则将第一个元素与第二个元素交换, 此时 N-1(0 ~ N-1) 最大
			将 0 ~ N-2 上的每两个相邻的元素比较, 若第一个元素比第二个元素大, 则将第一个元素与第二个元素交换, 此时 N-2(0 ~ N-2) 最大
			...
			将 0 和 1 上的元素比较, 若第一个元素比第二个元素大, 则将第一个元素与第二个元素交换, 此时 1(0 ~ 1) 最大
			逐个处理, 直至 0 元素和 1 元素比较交换有序, 程序完成. 时间复杂度 O(N^2)

		3. 插入排序
			默认 [0] 是有序序列, [1 ~ N-1] 是无序序列
			将 1 ~ N-1 上的元素逐个与有序序列元素从右至左看, 找到比左侧大的或没有元素时交换索引, 此时 [0 ~ 1] 有序
			将 2 ~ N-1 上的元素逐个与有序序列元素从右至左看, 找到比左侧大的或没有元素时交换索引, 此时 [0 ~ 2] 有序
			...
			将 N-2 ~ N-1 上的元素逐个与有序序列元素从右至左看, 找到比左侧大的或没有元素时交换索引, 此时[0 ~ N-2] 有序, 只剩 N-1
			逐个处理, 直至 0 ~ N-1 有序, 程序完成. 时间复杂度最好 O(N), 最差 O(N^2)
*/

// SelectionSort 选择排序
func SelectionSort(s []int) error {
	if len(s) <= 0 {
		return errors.New("序列不能为空")
	}
	for i := 0; i < len(s); i++ { // 外层循环: 逐个处理无序序列 [i ~ N-1] 上的每一个元素
		min := i                          // 初始化当前最小元素索引
		for j := i + 1; j < len(s); j++ { // 内层魂环: 逐个比较更新最小元素索引(i 与 [1 ~ N-1])
			if s[min] > s[j] {
				min = j
			}
		}
		s[i], s[min] = s[min], s[i]
	}
	return nil
}

// BubbleSort 冒泡排序
func BubbleSort(s []int) error {
	if len(s) <= 0 {
		return errors.New("序列不能为空")
	}
	for i := len(s) - 1; i >= 0; i-- { // 外层循环: 处理无序序列 0 ~ i, i 的右侧为有序序列
		for j := 0; j < i; j++ { // 内层循环: 逐个处理每相邻两个元素的大小关系, 直至无序序列上最大元素在序列的最右侧
			if s[j] > s[j+1] {
				s[j], s[j+1] = s[j+1], s[j]
			}
		}
	}
	return nil
}

// InsertionSort 插入排序
func InsertionSort(s []int) error {
	if len(s) <= 0 {
		return errors.New("序列不能为空")
	}
	for i := 1; i < len(s); i++ { // 外层循环: 默认 0 为有序序列, 逐个处理 无序序列 [1 ~ N-1] 上的每个元素
		for j := i; j > 0; j-- { // 内层循环: 处理当前元素, 将元素与之左侧的元素依次比小, 直至比左侧的元素大或者左侧没有元素
			if s[j] < s[j-1] {
				s[j], s[j-1] = s[j-1], s[j]
			}
		}
	}
	return nil
}

// todo 对数器

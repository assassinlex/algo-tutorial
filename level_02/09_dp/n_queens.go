package _9_dp

import "math"

/**
 * N 皇后问题 [时间复杂度: n^n]
 *
 * 定义:
 *     八皇后问题是一个以国际象棋为背景的问题, 如何能够在 8×8 的国际象棋棋盘上放置八个皇后,
 *     使得任何一个皇后都无法直接吃掉其他的皇后?
 *     为了达到此目的, 任两个皇后都不能处于同一条横行, 纵行或斜线上.
 *     八皇后问题可以推广为更一般的 n 皇后摆放问题, 这时棋盘的大小变为 n×n, 而皇后个数也变成n.
 *     当且仅当 n = 1或 n ≥ 4 时问题有解 [n ≥ 32 时计算机也无法解出答案]
 *
 * 解的个数:
 *   N[皇后数]  U[独立解: 可行解中通过旋转、镜像得到的算重复方案]  D[可行解: 所有可行的方案]
 *   ---------------------------------------------------------------------------------------------—----
 *   | N |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  | 11   |  12   |  13   |   14   |
 *   --------------------------------------------------------------------------------------------------
 *   | U |  1  |  0  |  0  |  1  |  2  |  1  |  6  |  12 | 46  |  92  | 341  | 1787  | 9233  |  45752 |
 *   --------------------------------------------------------------------------------------------------
 *   | D |  1  |  0  |  0  |  2  |  10 |  4  |  40 |  92 | 352 |  724 | 2680 | 14200 | 73712 | 365596 |
 *   --------------------------------------------------------------------------------------------------
 */

func Queen1(n int) int {
	if n < 1 {
		return 0
	}
	record := make([]int, n)
	return queue1(0, record, n)
}

// Queen1 方法一:
// 当前来到 i 行, 在 i 行的某一列放一个皇后 [一行只放一个, 避免同行的情况判断, 0 ~ i-1 行已作出决定]
// 在 i 行上的所有列进行尝试放置皇后, 保证与之前所有的皇后不同列且不在同一斜线上
// 参数说明:
//     row: 第 row 行
//     record: record[x] = y, 第 x 行 第 y 列 代表皇后放置的位置
//     n: 几皇后
//     返回值: n 皇后的可行解
func queue1(row int, record []int, n int) int {
	if row == n { // 所有行已经决定完全, 此时 0 ~ n-1 行的皇后摆放作为一种可行解返回
		return 1
	}
	res := 0
	for col := 0; col < n; col++ {
		// 若在 row 行 col 列合法, 则将解法累加, 若不合法, 去 row 行 col+1 列去尝试
		if isValid(record, row, col) {
			record[row] = col               // 记录此时放置的位置 [col 可能并未到达 n-1]
			res += queue1(row+1, record, n) // 去下一行尝试下一个皇后的位置
		}
	}
	// 若所有的 col 列都无法放置皇后, 说明 row-1 行的皇后放错了, 返回 0
	// 到达上一次递归的 col 列, col+1 继续尝试[递归]
	return res
}

// 第 row 行, 第 col 列放置皇后是否合法
// 判断 i[0 ~ row-1] 行中是否有皇后与 row 行 col 列的皇后同列, 或者在同一斜线上
// 同列: record[i] == col
// 同斜线: |i - row| == |record[i] - col| [行的绝对值差 == 列的绝对值差]
func isValid(record []int, row, col int) bool {
	for i := 0; i < row; i++ {
		if col == record[i] || int(math.Abs(float64(row-i))) == int(math.Abs(float64(col-record[i]))) {
			return false
		}
	}
	return true
}

func Queen2(n int) int {
	if n < 1 || n > 32 {
		return 0
	}
	limit := -1
	if n != 32 {
		// 假设 n = 8
		// 1 << 8 = 00000000 00000000 00000001 00000000
		// ~ - 1  = 00000000 00000000 00000000 11111111
		// limit 就是 n 皇后的设定值
		limit = (1 << n) - 1
	}
	return queen2(limit, 0, 0, 0)
}

// queen2 方法二:
// ********************
// * 请不要超过 32 皇后 *
// ********************
// 摆放皇后有两个限制, 不能同列, 不能同斜线<左斜线、右斜线>
// 准备一个 int32 的数 limit[1 <= limit <= 32 ], 有几个皇后, limit 右边的二进制位就有几个 1, 余下全是 0
// 如八皇后, limit 的二进制位就是     00000000 00000000 00000000 11111111
// 列限制:    初始 colLimit 规定为   00000000 00000000 00000000 00000000
// 左斜线限制: 初始 leftLimit 规定为  00000000 00000000 00000000 00000000
// 右斜线限制: 初始 rightLimit 规定为 00000000 00000000 00000000 00000000
// 每当在 row 行的 col 列放了一个皇后,
// 将 colLimit 对应的位置标为 1, 代表此处已经无法再放置皇后
//   leftLimit 将 colLimit 标 1 的位置左移一位
//  rightLimit 将 colLimit 标 1 的位置右移一位
// 如: colLimit  00000000 00000000 00000000 00001000, 标 1 的位置代表后续的行在这个位置上不能放皇后
// 则: leftLimit 00000000 00000000 00000000 00010000, 同上
//    rightLimit 00000000 00000000 00000000 00000100, 同上
// 当来到 row+1 行时, 将 ^(leftLimit | colLimit | rightLimit), 得到的是总的 limit'
// | 出来的结果 1 是不能放置皇后的位置, 取反后代表 1 的位置能放皇后
// 将开始准备的 limit & limit', 此时得到的结果二进制位置为 1 的是可以放置皇后的位置
// limit:  00000000 00000000 00000000 11111111
// limit': 11111111 11111111 11111111 11100011
// & 结果:  00000000 00000000 00000000 11100011  <为 1 的位置代表能放皇后>
// 然后依次取出最右边的 1, 尝试放置皇后, 递归
func queen2(limit, colLimit, leftLimit, rightLimit int) int {
	if colLimit == limit { // base case: 当列限制与初始限制一样, 代表皇后已放完, 将此时的情形作为一种结果返回
		return 1
	}
	// pos 的二进制位中所有是 1 的位置, 代表可以放置皇后
	pos := limit & (^(colLimit | leftLimit | rightLimit))
	mostRightOne := 0
	res := 0
	for pos != 0 {
		mostRightOne = pos & (^(pos) + 1) // 依次取出 pos 最右边的 1 二进制位, 代表去尝试放置皇后
		pos -= mostRightOne
		res += queen2(limit, colLimit|mostRightOne,
			(leftLimit|mostRightOne)<<1,
			(rightLimit|mostRightOne)>>1,
		) // 此时的右移要保证是无符号右移, 因为这里用的都是正数, 所以可以用 >>
	}
	return res
}
